# React 组件化开发

# 一、创建项目

## 1.安装脚手架

`npm i -g create-react-app`

## 2.创建项目

`create-react-app 项目名称`

## 3.目录结构

![目录结构](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16390558348691639055834863.png)

# 二、组件

## 1.组件的定义方式

### 1.1 类组件

特点：

- 需要注意 this 指向
- 组件的名称是大写字符开头
- 需要继承自 React.Component
- 必须实现 render 函数

```js
export default class App extends Component {
  // constructor可选，通常用来初始化数据
  constructor () {
    super()
    // 储存组件内部的数据
    this.state = {
      message: 'Hello'
    }
  }
  // 必须
  render () {
    return <h2>{this.state.message}</h2>
  }
}
```

### 1.2 函数组件

特点：

- 没有 this
- 没有内部状态（state）
- 会被更新并挂载，但没有生命周期函数

```js
export default function App () {
  return (
    <div>
      <h2>Hello</h2>
    </div>
  )
}
```

### 1.3 组件 render 返回值

- React 元素：通过 JSX 创建
- 数组或 fragments：使得 render 方法可以返回多个元素。

```js
render () {
    return [<h2>Hello</h2>, <h2>Hello</h2>]
  }
```

- Portals：可以渲染子节点到不同的 DOM 子树中。
- 字符串或数值类型：它们在 DOM 中会被渲染为文本节点
- 布尔类型或 null：什么都不渲染。

## 2.组件的生命周期

![组件的生命周期](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16393111158731639311115869.png)

### 2.1 挂载时

执行顺序：constructor->render->componentDidMount 方法

```js
import React, { Component } from 'react'

export default class Cycle extends Component {
  constructor () {
    console.log('constructor')
    super()
  }
  render () {
    console.log('render')
    return <div>Cycle</div>
  }

  componentDidMount () {
    console.log('componentDidMount方法')
  }
}
```

![挂载时](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16393112077011639311207700.png)

**constructor**

- 如果不初始化 state 或不进行方法绑定，则不需要 constructor
- 作用
  - 初始化内部的 state
  - 为事件绑定实例 this

**componentDidMount 方法**

- 会在组件挂载后（插入 DOM 树中）立即调用，依赖于 DOM 的操作可以在这里进行
- 发送网络请求最好的地方
- 可以在此处添加一些订阅（会在 componentWillUnmount 取消订阅）

### 2.2 更新时

执行顺序：render->componentDidUpdate 方法

```js
import React, { Component } from 'react'

export default class Cycle extends Component {
  constructor () {
    super()

    this.state = {
      counter: 0
    }
  }
  render () {
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <hr />
      </div>
    )
  }
  increment () {
    this.setState({ counter: this.state.counter + 1 })
  }

  componentDidUpdate (prevProps, prevState, snapshot) {
    console.log('componentDidUpdate方法')
  }
}
```

**componentDidUpdate**

- 会在更新后会被立即调用，首次渲染不会执行此方法
- 当组件更新后，可以在此处对 DOM 进行操作
- 如果对更新前后的 props 进行了比较，也可以选择在此处进行网络请求

### 2.2 卸载时

```js
import React, { Component } from 'react'
class Son extends Component {
  render () {
    return <h2>我是Son组件</h2>
  }

  componentWillUnmount () {
    console.log('调用了Son的componentWillUnmount方法')
  }
}

export default class Cycle extends Component {
  constructor () {
    super()

    this.state = {
      isShow: true
    }
  }
  render () {
    console.log('render')
    return (
      <div>
        Cycle
        <button onClick={e => this.changeCpnShow()}>切换</button>
        {this.state.isShow && <Son></Son>}
      </div>
    )
  }

  changeCpnShow () {
    this.setState({ isShow: !this.state.isShow })
  }

  componentDidUpdate (prevProps, prevState, snapshot) {
    console.log('componentDidUpdate方法')
  }
}
```

**componentWillUnmount 方法**

- 会在组件卸载及销毁之前直接调用
- 在此方法中执行必要的清理操作：清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等

## 3.组件通讯

### 3.1 父子通讯

父组件通过 属性=值 的形式来传递给子组件数据，子组件通过 props 参数获取父组件传递过来的数据

```js
import React, { Component } from 'react'

// 类组件
class ChildCpn extends Component {
  componentDidMount () {
    console.log(this.props, 'componentDidMount')
  }

  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>
  }
}

// 函数组件
function ChildFun (props) {
  const { name, age, height } = props
  return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>
}

// 父组件
export default class Son extends Component {
  render () {
    return (
      <div>
        <ChildCpn name='loveZero' age='18' height='1.58' />
        <ChildCpn name='千玺' age='20' height='1.78' />
        <ChildFun name='loveZero' age='18' height='1.58' />
        <ChildFun name='千玺' age='20' height='1.78' />
      </div>
    )
  }
}
```

#### propTypes

用于属性验证和默认值
[官网](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html)

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'
// 类组件
class ChildCpn extends Component {
  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>
  }
}
// 属性验证
ChildCpn.propTypes = {
  // 字符串类型，必填
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  height: PropTypes.string
}

// 默认值
ChildCpn.defaultProps = {
  name: 'loveZero',
  age: 18,
  height: '1.58'
}

// 父组件
export default class Son extends Component {
  render () {
    return (
      <div>
        <ChildCpn name='loveZero' age={18} height='1.58' />
        <ChildCpn name='千玺' age={20} height='1.78' />
        <ChildCpn />
      </div>
    )
  }
}
```

类组件的属性验证和默认值写法二

```js
class ChildCpn extends Component {
  // es6中的class fields写法
  static propTypes = {
    // 字符串类型，必填
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    height: PropTypes.string
  }

  static defaultProps = {
    name: 'loveZero',
    age: 18,
    height: '1.58'
  }
  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>
  }
}
```

#### 传递函数

```js
class CounterButton extends Component {
  render () {
    const { onClick } = this.props
    return <button onClick={onClick}>+1</button>
  }
}

// 父组件
export default class Son extends Component {
  constructor () {
    super()
    this.state = {
      num: 0
    }
  }
  render () {
    return (
      <div>
        <button
          onClick={e => {
            this.numClick()
          }}
        >
          +
        </button>
        <h2>{this.state.num}</h2>
        <CounterButton
          onClick={e => {
            this.numClick()
          }}
        />
      </div>
    )
  }
  numClick () {
    this.setState({
      num: this.state.num + 1
    })
  }
}
```

### 3.2 跨组件通讯

#### 3.2.1 props

使用 props 属性展开
![props](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394080416551639408041652.png)

```js
import React, { Component } from 'react'

function Sun (props) {
  return (
    <div>
      <h2>用户昵称: {props.nickname}</h2>
      <h2>用户等级: {props.level}</h2>
    </div>
  )
}

function Son (props) {
  return (
    <div>
      <Sun {...props} />
      <ul>
        <li>设置1</li>
        <li>设置2</li>
        <li>设置3</li>
        <li>设置4</li>
      </ul>
    </div>
  )
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      <div>
        <Son {...this.state} />
      </div>
    )
  }
}
```

#### 3.2.2 context

**1.创建 context**

```js
const UserContext = React.createContext({ 默认值 })
```

**2.父组件中使用**

```js
<UserContext.Provider value={this.state}>
  <Son />
</UserContext.Provider>
```

**3.后续组件中绑定**

```js
Sun.contextType = UserContext
```

`React.createContext`

- 创建一个 context 对象
- 会离自身最近开始匹配的 Provider 中读取 context 值
- 如果没找到 Provider 就会使用默认值

`Context.Provider`

- Provider 接收一个 value 属性，传递给消费组件
- 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染

`Class.contextType`

- 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象
- 使用 this.context 来消费最近 Context 上的那个值；
- 可以在任何生命周期中访问到它，包括 render 函数中

`Context.Consumer`

- 在函数式组件中使用

```js
// 类组件中使用
import React, { Component } from 'react'
// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1
})

class Sun extends Component {
  render () {
    console.log(this.context)
    return (
      <div>
        <h2>用户昵称: {this.context.nickname}</h2>
        <h2>用户等级: {this.context.level}</h2>
      </div>
    )
  }
}
Sun.contextType = UserContext

class Son extends Component {
  render () {
    console.log(this.context)
    return (
      <div>
        <Sun />
        <ul>
          <li>设置1</li>
          <li>设置2</li>
          <li>设置3</li>
          <li>设置4</li>
        </ul>
      </div>
    )
  }
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      <div>
        <UserContext.Provider value={this.state}>
          <Son />
        </UserContext.Provider>
      </div>
    )
  }
}
```

```js
// 在函数式组件中使用
import React, { Component } from 'react'
// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1
})

function Sun () {
  return (
    <UserContext.Consumer>
      {value => {
        return (
          <div>
            <h2>用户昵称:{value.nickname} </h2>
            <h2>用户等级:{value.level} </h2>
          </div>
        )
      }}
    </UserContext.Consumer>
  )
}

class Son extends Component {
  render () {
    return (
      <div>
        <Sun />
        <ul>
          <li>设置1</li>
          <li>设置2</li>
          <li>设置3</li>
          <li>设置4</li>
        </ul>
      </div>
    )
  }
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      <div>
        <UserContext.Provider value={this.state}>
          <Son />
        </UserContext.Provider>
      </div>
    )
  }
}
```

## 4.react 实现插槽

```js
import React, { Component } from 'react'

class NavBar extends Component {
  render () {
    const { leftSlot, centerSlot, rightSlot } = this.props

    return (
      <div className='nav-item nav-bar'>
        <div className='nav-left'>{leftSlot}</div>
        <div className='nav-item nav-center'>{centerSlot}</div>
        <div className='nav-item nav-right'>{rightSlot}</div>
      </div>
    )
  }
}

export default class Slot extends Component {
  render () {
    const leftJsx = <span>aaa</span>
    return (
      <div>
        <NavBar
          leftSlot={leftJsx}
          centerSlot={<strong>bbb</strong>}
          rightSlot={<a href='/#'>ccc</a>}
        />
      </div>
    )
  }
}
```
