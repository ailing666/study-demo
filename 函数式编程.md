# 函数式编程

## 1.函数式编程优势

- 更少的时间
- 更少的 BUG
- 更好的测试性
- 更方便调试
- 适合并发执行
- 更高的复用性
- 支持 tree-shaking
- React 和 vue3 大量使用函数式编程

## 2.什么是函数式编程

函数式编程是一种编程范式

- 面向过程式编程

```js
// 从上到下一行行执行，一行行写
let a = 1
let b = 2
let res1 = a + b
console.log(res1)
```

- 面向对象式编程

```JavaScript
class Calculaor {
  add (a, b) {
    return a + b
  }
}
let c = new Calculaor()
console.log(c.add(1, 2))

```

- 函数式编程

```JavaScript
// 函数其实是数学上的概念 y = f(x)
function addNum (a, b) {
  return a + b
}
let res2 = add(1, 2)
console.log(res2)
```

## 3. First-class Function(头等函数）

函数是头等函数

- 函数可以赋值给变量
- 函数可以作为参数
- 函数可以作为返回值

```js
function add (a, b) {
  return a + b
}

// 可以给变量赋值
let add1 = add

// 可以作为参数
function exec (fn, a, b) {
  return fn(a, b)
}

exec(add, 1, 2)

// 可以作为返回值
function exec2 (fn) {
  return function (a, b) {
    return fn(a, b)
  }
}
exec2(add)(1, 2)
```

作为参数和返回值的函数被称为高阶函数，高阶函数是函数式编程的基础

## 4.闭包（ closure)

- 一个函数和对其周围状态的引用捆绑在一起这样的组合就是闭包

- 闭包让你可以在一个内层函数中访问到其外层函数的作用域的变量

```JavaScript
function init () {
  let name = 'hello' // name 是一个被 init 创建的局部变量
  // displayName() 是内部函数，一个闭包
  function displayName () {
    console.log(name) // 使用了父函数中声明的变量
  }
  displayName()
}
init()

```

## 5.纯函数

### 5.1 什么是纯函数

- 函数的返回结果只依赖于它的参数，相同的輸入始终得到相同的输出
- 函数执行过程里面没有副作用（一个函数执行过程对产生了外部可观察的变化那么就可以说这个函数是有副作用）

```JavaScript
// 纯函数
function add (a, b) {
  return a + b
}

// 非纯函数
let c = 1
let d = 2
function add2 (a, b) {
  // 修改了外部变量
  d++
  // 返回值依赖了外部变量
  return a + b + c
}
add2()
console.log(d)

```

### 5.2 优点

#### 5.2.1 可缓存

创建一个会缓存 func 结果的函数。
func 在调用时 this 会绑定在缓存函数上

```js
function add (a, b) {
  console.log('执行了')
  return a + b
}
// 相同参数调用3次，函数会执行3次
console.log(add(1, 2))
console.log(add(1, 2))
console.log(add(1, 2))

/*打印结果
  执行了
  3
  执行了
  3
  执行了
  3
 */
// 缓存
function memoize (fn) {
  // 深拷贝参数
  const resolver = (...args) => JSON.stringify(args)
  // 定义缓存对象，存放参数和结果的对应关系
  let cache = {}
  return (...args) => {
    // 将传入的参数作为key
    const key = resolver(...args)
    // 如果cache中对应参数已经有值了，就直接返回值，否则就将函数调用该值的结果存入缓存中
    return cache[key] ? cache[key] : (cache[key] = fn(...args))
  }
}
// 缓存add函数
const memoizeAdd = memoize(add)
console.log(memoizeAdd(1, 2))
console.log(memoizeAdd(1, 2))
console.log(memoizeAdd(1, 2))
/*打印结果
  执行了
  3
  3
  3
 */
```

#### 5.2.1 可测试

只需简单地给函数一个输入，然后断言输出就好了。不依赖于上下文环境

```JavaScript
function add (a, b) {
  return a + b
}
test('测试1+1', () => {
  expect(add(1, 2)).toBe(3)
})

```

## 6.柯里化

把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

```JavaScript
function add (a, b, c) {
  return a + b + c
}
// 柯里化函数
function curry (fn) {
  // 函数形参个数
  let argsLength = fn.length
  let curried = (...args) => {
    // 如果传入的参数小于形参的个数
    if (args.length < argsLength) {
      // 将传入的参数和参数后的第一个参数作为参数，递归调用curried
      return (...rest) => curried(...args, ...rest)
    }
    // 如果传入的参数不小于形参的个数，就将所有参数传入返回函数调用值
    return fn(...args)
  }
  return curried
}
let curriedAdd = curry(add)
console.log(curriedAdd(1)(2)(3))

```
