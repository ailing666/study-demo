# http模块

## 一、http初体验

```js
// 引入http模块
const http = require('http')

// 创建http请求
const server = http.createServer((req, res) => {
  res.end('hello http')
})

// 监听http请求
server.listen(8888, 'localhost', () => {
  console.log('启动成功');
})

```

此时每次修改http请求，都需要重新运行代码，比较麻烦。可以借用工具`nodemon`实现自动监听

1. 安装`npm install -g nodemon`
2. 终端使用`nodemon`启动服务器
![nodemon](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16375729062861637572906278.png)

## 二、参数解析

### 1.创建服务器

1. `http.createServer`创建

```js
const server1 = http.createServer((req, res) => {
  res.end('server1')
})

server1.listen(8000, 'localhost', () => {
  console.log('server1启动成功');
})
```

2. `new http.Server`创建

```js
const server2 = new http.Server((req, res) => {
  res.end('server2')
})
server2.listen(8001, 'localhost', () => {
  console.log('server2启动成功');
})
```

### 2.listen参数

1. 端口port:可以不传，系统会默认分配端口，通常会写入到环境变量中；
2. 主机host通常可以传入 localhost、ip地址127.0.0.1、或者ip地址0.0.0.0,默认是0.0.0.0
   1. localhost:本质上是一个域名，通常情况下会被解析成127.0.0.1;
   2. 127.0.0.1:回环地址,表达的意思其实是主机自己发出去的包，直接被自己接收
      + 在网络层直接就被获取到了，是不会经常数据链路层和物理层的
      + 监听127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的；
   3. 0.0.0.0
      + 监听IPV4上所有的地址，再根据端口找到不同的应用程序
      + 监听0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的
3. 回调函数：服务器启动成功时的回调函数

### 3.request对象

request对象中封装了客户端给我们服务器传递过来的所有信息

```js
const server = http.createServer((req, res) => {
  console.log('req.url', req.url);
  console.log('req.method', req.method);
  console.log('req.headers', req.headers);
  res.end('server')
})

```

![request对象](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376533698081637653369780.png)
![request对象post](<https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/163765359097616376535909>
  // 直接打印  /login?name=loveZero&password=666
  console.log('req.url', req.url);
      // 直接打印  /login?name=loveZero&password=666
      console.log('req.url', req.url);

   ```

2. url.parse和qs.parse

通过url.parse可以得到pathname和query
解析方便，但是现在已废弃

```js
  const url = require('url')
  const qs = require('querystring')
  const server = http.createServer((req, res) => {
    console.log('url.parse', url.parse(req.url));
    const { query } = url.parse(req.url);
    if (url.parse(req.url).pathname === '/login') {
      const { username, password } = qs.parse(query);
      console.log(username, password);
    }
  })

```

![url.parse](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376551274871637655127477.png)

3. 通过URL实例

  ```js
  // 通过URL实例能得到pathname和searchParams
  const baseURL = req.protocol + '://' + req.headers.host + '/';
  const reqUrl = new URL(req.url, baseURL);
  console.log('reqUrl', reqUrl);
  const { pathname, searchParams } = reqUrl
  if (pathname === '/login') {
    console.log(searchParams.get('name'), searchParams.get('password'));
    res.end("请求结果~");
  }
  ```

![URL实例](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376552102891637655210281.png)

#### 3.2 request.method

通过`method`判断是否是POST请求，可以拿到请求中的`body`

```js
// 引入http模块
const http = require('http')

// 创建http请求
const server = http.createServer((req, res) => {
  // 通过URL实例能得到pathname和searchParams
  const baseURL = req.protocol + '://' + req.headers.host + '/';
  const reqUrl = new URL(req.url, baseURL);
  if (reqUrl.pathname === '/login') {
    if (req.method === 'POST') {
      req.setEncoding('utf-8');
      req.on('data', (data) => {
        console.log('%cdata: ', 'color: #58e2ba;', data);
        const { name, password } = JSON.parse(data);
        console.log(name, password);
      });
      res.end("请求结果~");
    }
  }
})

server.listen(8000, 'localhost', () => {
  console.log('server启动成功');
})
```

#### 3.3 request.headers

+ content-type是这次请求携带的数据的类型
  + application/json表示是一个json类型；
  + text/plain表示是文本类型；
  + application/xml表示是xml类型；
  + multipart/form-data表示是上传文件

+ content-length：文件的大小和长度

+ keep-alive：
  + http是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；
  + 在http1.0中，如果想要继续保持连接：
    + 浏览器需要在请求头中添加 connection: keep-alive；
    + 服务器需要在响应头中添加 connection:keey-alive；
    + 当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；
  + 在http1.1中，所有连接默认是 connection: keep-alive的；
    + 不同的Web服务器会有不同的保持 keep-alive的时间；
    + Node中默认是5s中；

+ accept-encoding：告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件；
+ accept：告知服务器，客户端可接受文件的格式类型；
+ user-agent：客户端相关的信息；
![headers](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16377347724631637734772452.png)
![headers](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16377347724631637734772452.png)
